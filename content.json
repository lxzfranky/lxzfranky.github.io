{"meta":{"title":"Franky's Diary","subtitle":"把有限的生命投入到我开心就好的事情中去","description":null,"author":"lxzfranky","url":"http://www.lxzfranky.com"},"pages":[{"title":"about","date":"2017-09-06T11:03:49.000Z","updated":"2017-09-07T10:12:56.000Z","comments":true,"path":"about/index.html","permalink":"http://www.lxzfranky.com/about/index.html","excerpt":"","text":"拜访我的朋友 广训大神 https://zhgxun.github.io/ 娟娟大神 http://lyj1215.com/"}],"posts":[{"title":"php中接口、抽象类区别","slug":"php-interface-absclass","date":"2017-09-07T15:06:19.000Z","updated":"2017-09-07T15:11:00.000Z","comments":true,"path":"2017/09/07/php-interface-absclass/","link":"","permalink":"http://www.lxzfranky.com/2017/09/07/php-interface-absclass/","excerpt":"","text":"php中接口、抽象类区别 接口 1. 对接口的使用是通过关键字implements 2. 接口不能定义成员变量（包括类静态变量），能定义常量 3. 子类必须实现接口定义的所有方法 4. 接口只能定义不能实现该方法 5. 接口没有构造函数 6. 接口中的方法和实现它的类默认都是public类型的 抽象类 1. 对抽象类的使用是通过关键字extends 2. 不能被实例化，可以定义子类必须实现的方法 3. 子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松） 4. 如一个类中有一个抽象方法，则该类必须定义为抽象类 5. 抽象类可以有构造函数 6. 抽象类中的方法可以使用private,protected,public来修饰。 7. 一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。","categories":[{"name":"PHP学习","slug":"PHP学习","permalink":"http://www.lxzfranky.com/categories/PHP学习/"}],"tags":[{"name":"php","slug":"php","permalink":"http://www.lxzfranky.com/tags/php/"},{"name":"面试","slug":"面试","permalink":"http://www.lxzfranky.com/tags/面试/"}]},{"title":"hexo+github搭建免费个人博客详细教程","slug":"env-gitblog","date":"2017-09-06T05:39:39.000Z","updated":"2017-09-07T15:09:16.000Z","comments":true,"path":"2017/09/06/env-gitblog/","link":"","permalink":"http://www.lxzfranky.com/2017/09/06/env-gitblog/","excerpt":"准备工作 一个github账号 安装node.js(node官网下载)、npm(推荐brew安装) 安装git","text":"准备工作 一个github账号 安装node.js(node官网下载)、npm(推荐brew安装) 安装git 一 在GitHub创建仓库 新建一个名为你的用户名.github.io的仓库 仓库名字必须是：lxzfranky.github.io，其中lxzfranky是我的用户名 二 绑定域名（此步骤可以省略） 如果不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问 阿里云购买域名后 执行 1ping xxx.github.com 得到对应的IP地址，去万网的控制台中解析购买的域名 在blog/public 目录下新建一个CNAME文件(无后缀名) 将自己的域名 www.lxzfranky.com填入其中 至此自己的博客基本已经完成 三 安装hexo 目前有很多工具我这里主要用的hexo其他还有Jekyll Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网：http://hexo.io github: https://github.com/hexojs/hexo 安装 1$ npm install -g hexo 初始化在电脑的某个地方新建一个名为blog的文件夹（名字可以随便取），我的是~/WorkSpace/blog 在blog目录下执行 1hexo init 至此hexo安装完毕 四 本地运行 在项目根目录下执行 1hexo s # 启动服务 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容 hexo一些常用的命令 基本命令 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 命令组合 12hexo s -g #生成并本地预览hexo d -g #生成并上传 五 配置git 编辑 根目录下的 _config.yml 文件 12345deploy: type: git repo: https://github.com/lxzfranky/lxzfranky.github.io branch: master message: 提交博客内容 安装插件 1npm install hexo-deployer-git --save 执行下面命令发布代码到博客 1hexo d 六 下载好看的主题和有用的插件 Plugins: https://hexo.io/plugins/ Themes: https://hexo.io/themes/ 主题里面自带使用教程这里就不多说了 七 其他一些设置 详见 根目录下的 _config.yml 八 开始写博客吧 到根目录下执行如下命令hexo会帮我们在_posts下生成相关md文件，打开这个文件编辑就好了 1hexo new 'my-first-blog' 完整文档格式如下 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2017-09-06 13:39:39 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://www.lxzfranky.com/categories/环境配置/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.lxzfranky.com/tags/hexo/"},{"name":"环境","slug":"环境","permalink":"http://www.lxzfranky.com/tags/环境/"}]},{"title":"常用排序算法总结","slug":"algorithm-sort","date":"2017-08-26T03:20:10.000Z","updated":"2017-09-07T15:09:16.000Z","comments":true,"path":"2017/08/26/algorithm-sort/","link":"","permalink":"http://www.lxzfranky.com/2017/08/26/algorithm-sort/","excerpt":"常见排序算法总结，还有很多要完善的","text":"常见排序算法总结，还有很多要完善的 直接插入排序原理：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。要点：设立哨兵，作为临时存储和判断数组边界之用。实现：12345678910111213141516function insertSort(&amp;$arr)&#123; $size = count($arr); for($i=1;$i&lt;$size;$i++)&#123; $tmp = $arr[$i]; $j = $i-1; while ($j&gt;-1 &amp;&amp; $tmp &lt; $arr[$i]) &#123; $arr[$j+1] = $arr[$j]; $j--; &#125; $arr[$j+1]=$tmp; &#125;&#125;$arr = array(0,4,3,5,7,2,9,1,6);insertSort($arr);print_r($arr); 希尔排序原理：又称增量缩小排序。先将序列按增量划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小增量直至为1，最后使用直接插入排序完成排序。要点：增量的选择以及排序最终以1为增量进行排序结束。实现：123function shellSort()&#123;&#125; 冒泡排序原理：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。要点：设计交换判断条件，提前结束以排好序的序列循环。实现：123456789101112131415161718function BubbleSort(&amp;$arr)&#123; $size = count($arr); for($i=0;$i&lt;$size;$i++)&#123; for($j=$i;$j&lt;$size;$j++)&#123; if($arr[$i] &gt; $arr[$j])&#123; $tmp = $arr[$j]; $arr[$j] = $arr[$i]; $arr[$i] = $tmp; &#125; &#125; &#125; return $arr;&#125;$arr = array(0,4,3,5,7,2,9,1,6);BubbleSort($arr);print_r($arr); 快速排序原理：不断寻找一个序列的中点，然后对中点左右的序列递归的进行排序，直至全部序列排序完成，使用了分治的思想。要点：递归、分治实现：12345678910111213141516171819202122232425function quickSort($arr)&#123; if(count($arr) &gt; 1)&#123; $k = $arr[0]; $x = array(); $y = array(); $size = count($arr); for($i = 1; $i &lt; $size ;$i++)&#123; if($arr[$i] &lt;= $k)&#123; $x[] = $arr[$i]; &#125;else&#123; $y[] = $arr[$i]; &#125; &#125; $x = quickSort($x); $y = quickSort($y); return array_merge($x, array($k), $y); &#125;else&#123; return $arr; &#125;&#125;$arr = array(0,4,3,5,7,2,9,1,6);$res = quickSort($arr);print_r($res);exit; 直接选择排序原理：将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，有序区扩大一个，循环最终完成全部排序。要点：实现：1234567891011121314151617181920212223function SelectSort(&amp;$arr)&#123; $length = count($arr); for($i = 0; $i &lt; $length-1; $i ++)&#123; $mink = $i; // 每次从未排序数组中找到最小值的坐标 for ($j = $i + 1; $j &lt; $length; $j++) &#123; if ($arr[$j] &lt; $arr[$mink]) &#123; $mink = $j; &#125; &#125; // 将最小值放在最前面 if ($mink != $i) &#123; $temp = $arr[$mink]; $arr[$mink] = $arr[$i]; $arr[$i] = $temp; &#125; &#125;&#125;$arr = array(0,4,3,5,7,2,9,1,6);SelectSort($arr);print_r($arr); 堆排序原理：利用大根堆或小根堆思想，首先建立堆，然后将堆首与堆尾交换，堆尾之后为有序区。要点：建堆、交换、调整堆实现：12345678910111213141516171819202122232425262728293031323334353637383940414243//因为是数组,下标从0开始,所以,下标为n根结点的左子结点为2n+1,右子结点为2n+2; //初始化值,建立初始堆$arr=array(49,38,65,97,76,13,27,50);$arrSize=count($arr);//将第一次排序抽出来，因为最后一次排序不需要再交换值了。buildHeap($arr,$arrSize);for($i=$arrSize-1;$i&gt;0;$i--)&#123; swap($arr,$i,0); $arrSize--; buildHeap($arr,$arrSize); &#125;print_r($arr);//用数组建立最小堆function buildHeap(&amp;$arr,$arrSize)&#123; //计算出最开始的下标$index,如图,为数字\"97\"所在位置,比较每一个子树的父结点和子结点,将最小值存入父结点中 //从$index处对一个树进行循环比较,形成最小堆 for($index=intval($arrSize/2)-1; $index&gt;=0; $index--)&#123; //如果有左节点,将其下标存进最小值$min if($index*2&lt;$arrSize)&#123; $min=$index*2; //如果有右子结点,比较左右结点的大小,如果右子结点更小,将其结点的下标记录进最小值$min if($index*2+1&lt;$arrSize)&#123; if($arr[$index*2+1]&lt;$arr[$min])&#123; $min=$index*2+1; &#125; &#125; //将子结点中较小的和父结点比较,若子结点较小,与父结点交换位置,同时更新较小 if($arr[$min]&lt;$arr[$index])&#123; swap($arr,$min,$index); &#125; &#125; &#125;&#125;//此函数用来交换下数组$arr中下标为$one和$another的数据function swap(&amp;$arr,$one,$another)&#123; $tmp=$arr[$one]; $arr[$one]=$arr[$another]; $arr[$another]=$tmp;&#125; 归并排序原理：将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。要点：归并、分治实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 实际实现归并排序的程序 * @param &amp;$arr array 需要排序的数组 * @param $left int 子序列的左下标值 * @param $right int 子序列的右下标值 */function mSort(&amp;$arr, $left, $right) &#123; if($left &lt; $right) &#123; //说明子序列内存在多余1个的元素，那么需要拆分，分别排序，合并 //计算拆分的位置，长度/2 去整 $center = floor(($left+$right) / 2); //递归调用对左边进行再次排序： mSort($arr, $left, $center); //递归调用对右边进行再次排序 mSort($arr, $center+1, $right); //合并排序结果 mergeArray($arr, $left, $center, $right); &#125;&#125;/** * 将两个有序数组合并成一个有序数组 * @param &amp;$arr, 待排序的所有元素 * @param $left, 排序子数组A的开始下标 * @param $center, 排序子数组A与排序子数组B的中间下标，也就是数组A的结束下标 * @param $right, 排序子数组B的结束下标（开始为$center+1) */function mergeArray(&amp;$arr, $left, $center, $right) &#123; //设置两个起始位置标记 $a_i = $left; $b_i = $center+1; while($a_i&lt;=$center &amp;&amp; $b_i&lt;=$right) &#123; //当数组A和数组B都没有越界时 if($arr[$a_i] &lt; $arr[$b_i]) &#123; $temp[] = $arr[$a_i++]; &#125; else &#123; $temp[] = $arr[$b_i++]; &#125; &#125; //判断 数组A内的元素是否都用完了，没有的话将其全部插入到C数组内： while($a_i &lt;= $center) &#123; $temp[] = $arr[$a_i++]; &#125; //判断 数组B内的元素是否都用完了，没有的话将其全部插入到C数组内： while($b_i &lt;= $right) &#123; $temp[] = $arr[$b_i++]; &#125; //将$arrC内排序好的部分，写入到$arr内： for($i=0, $len=count($temp); $i&lt;$len; $i++) &#123; $arr[$left+$i] = $temp[$i]; &#125;&#125;$arr = array(0,4,3,5,7,2,9,1,6);$len = count($arr);//求得数组长度mSort($arr, 0, $len-1);print_r($arr);exit; 基数排序原理：将数字按位数划分出n个关键字，每次针对一个关键字进行排序，然后针对排序后的序列进行下一个关键字的排序，循环至所有关键字都使用过则排序完成。要点：对关键字的选取，元素分配收集。实现：123function RadixSort()&#123;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://www.lxzfranky.com/categories/算法学习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.lxzfranky.com/tags/算法/"},{"name":"排序","slug":"排序","permalink":"http://www.lxzfranky.com/tags/排序/"}]},{"title":"KMP算法学习","slug":"algorithm-kmp","date":"2017-08-02T01:20:29.000Z","updated":"2017-09-07T15:09:16.000Z","comments":true,"path":"2017/08/02/algorithm-kmp/","link":"","permalink":"http://www.lxzfranky.com/2017/08/02/algorithm-kmp/","excerpt":"","text":"","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://www.lxzfranky.com/categories/算法学习/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.lxzfranky.com/tags/算法/"},{"name":"kmp","slug":"kmp","permalink":"http://www.lxzfranky.com/tags/kmp/"}]},{"title":"Laravel5.4学习笔记","slug":"php-laravel","date":"2017-08-01T08:16:23.000Z","updated":"2017-09-06T15:11:09.000Z","comments":true,"path":"2017/08/01/php-laravel/","link":"","permalink":"http://www.lxzfranky.com/2017/08/01/php-laravel/","excerpt":"最近公司开发新项目需要用Laravel框架，就学习了下做了一些笔记，方便以后回顾吧。 常用网址 API Laravel中文文档 Laravel中文社区 Laravel英文官网","text":"最近公司开发新项目需要用Laravel框架，就学习了下做了一些笔记，方便以后回顾吧。 常用网址 API Laravel中文文档 Laravel中文社区 Laravel英文官网 入门指南 通过 Laravel 安装工具 12345~/.composer/vendor/bin/composer global require \"laravel/installer\"//与直接下载远吗解压没有什么区别1. 更改权限允许web服务器写入 storage 和 bootstrap/cache2. .env.example 文件重命名为 .env3. php artisan key:generate 更新到env中 开发环境部署 本地开发服务器 12345678php artisan servephp artisan migrate:install //数据库迁移php artisan make:controller PostControllerphp artisan make:migration create_posts_talbe //创建数据迁移php artisan make:model Post //创建模型php artisan tinkerphp artisan make:auth………… 核心概念 Laravel 的请求生命周期 1. 一个 Laravel 应用的所有请求的入口都是 public/index.php 文件 2. index.php 文件载入自动加载器定义，并从 bootstrap/app.php 文件获取到 Laravel 应用实例 3. 传入的请求会被发送给 HTTP 内核或者 console 内核，ge：app/Http/Kernel.php（HTTP内核） 4. HTTP内核继承自 Illuminate\\Foundation\\Http\\Kernel 定义了一个 bootstrappers等 5. HTTP内核同时定义了一个 HTTP中间件 6. handle方法：接收一个 Request 并返回一个 Response 服务提供者 服务提供者是所有 Laravel 应用程序引导启动的中心所在。包括您自己的应用程序，以及所有的 Laravel 核心服务，都是通过服务提供者引导启动的。 所有的服务提供者都配置在config/app.php文件中的providers数组中。首先，所有提供者的register方法会被调用（只能将事务绑定到 服务容器。不应该在 register 方法中尝试注册任何事件监听器，路由或者任何其他功能。），接下来，一旦所有提供者注册完成，boot方法将会被调用。 未完待续 之前学习的笔记现在返回看的时候感觉可以精简一下，有空的时候再整理一个精简的版本。","categories":[{"name":"PHP学习","slug":"PHP学习","permalink":"http://www.lxzfranky.com/categories/PHP学习/"}],"tags":[{"name":"php","slug":"php","permalink":"http://www.lxzfranky.com/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://www.lxzfranky.com/tags/laravel/"}]}]}